{
  "hash": "05a49c4f836881ef7dc82e9702632db0",
  "result": {
    "markdown": "---\ntitle: \"Buscando informações na Wikipédia: Lista de episódios de Naruto Shippuden\"\nsubtitle: \"Post publicado no blog da Curso-R.\"\nauthor: \"Beatriz Milz\"\ndate: '2021-05-24'\ncategories: [\"Tutorial\", \"Web Scraping\", \"Data cleaning\", \"purrr\", \"rvest\"]\ntoc: true\nimage: featured-photo.jpeg\n---\n\n\n\n\nLeia o post no blog da Curso-R: [acesse aqui!](https://blog.curso-r.com/posts/2021-05-24-naruto/)\n\nAlguns animes tem muitos *fillers*, que são episódios que não se baseiam na história original, e não agregam na história principal.\nMuitas vezes parece uma **encheção de linguiça** mesmo, contendo diversos episódios em sequência que não contribuem com a história que estamos acompanhando.\n\nNaruto é um caso onde existem muuuitos fillers!\nEntão eu pulo esses episódios sem dó, usando a [Lista de episódios de Naruto Shippuden](https://pt.wikipedia.org/wiki/Lista_de_epis%C3%B3dios_de_Naruto_Shippuden) disponível no Wikipédia.\n\nO objetivo deste post é apresentar uma forma de importar estes dados para o R, para que a gente ~~não precise acessar toda hora a página do wikipedia~~ consiga fazer uma visualização da distribuição de episódios fillers ao longo dos 500 episódios do anime!\nVamos lá, *dattebayo*!\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-1_92f1062282700bc0e4944cd697c92e6c'}\n::: {.cell-output-display}\n![](https://media.giphy.com/media/ohT97gdpR40vK/source.gif){fig-align='center'}\n:::\n:::\n\n\n## Coleta de dados com Web Scraping\n\nVamos usar uma técnica chamada *web scraping*, que é baseada em raspar informações de páginas de internet.\nPrimeiro, precisamos buscar o código HTML referente à página do Wikipédia que queremos raspar as informações sobre os episódios de Naruto Shippuden:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_bb2fdc1b72b1526d1891ff57f5e73d96'}\n\n```{.r .cell-code}\n# Criando um objeto chamado \"url_wiki\", que contém a url da página do wikipedia\nurl_wiki <-\n  \"https://pt.wikipedia.org/wiki/Lista_de_epis%C3%B3dios_de_Naruto_Shippuden\"\n\n# Lendo o código html referente à página do wikipedia\n# E salvando em um objeto chamado wikipedia_html\nwikipedia_html  <- rvest::read_html(url_wiki)\n```\n:::\n\n\nO que o objeto `wikipedia_html` contém?\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_c58ceea4bf79a0cbb04b712d261f076d'}\n\n```{.r .cell-code}\nwikipedia_html\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{html_document}\n<html class=\"client-nojs\" lang=\"pt\" dir=\"ltr\">\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8 ...\n[2] <body class=\"skin-vector skin-vector-search-vue mediawiki ltr sitedir-ltr ...\n```\n:::\n:::\n\n\nEsse objeto apresenta o código HTML referente à página que queremos raspar!\n\n### Buscando informações sobre a primeira temporada\n\nAgora precisamos descobrir como acessar as informações que queremos.\n[Olhando a página](https://pt.wikipedia.org/wiki/Lista_de_epis%C3%B3dios_de_Naruto_Shippuden), podemos ver que os dados de cada temporada estão apresentados em uma tabela diferente.\nVamos tentar primeiramente buscar as informações para a tabela referente à primeira temporada, e quando este código estiver funcionando bem, podemos adaptar o código para buscar os dados das outras temporadas!\n\nEstou utilizando o navegador Google Chrome, e esse navegador tem uma opção que ajuda muito a explorar o código: o inspetor de elementos!\nPara acessar essa ferramenta, você pode usar o atalho `Ctrl` + `Shift` + `C`, ou clicando no menu superior: \"Visualizar\" \\> \"Desenvolvedor\" \\> \"Inspecionar elementos\".\nCaso você utilize outro navegador, recomendo que procure o equivalente ao inspetor de elementos deste navegador.\n\nAo acessar o inspetor de elementos, podemos navegar com o cursor e conseguir visualizar o código equivalente a essa parte da página.\nUma forma de localizar conteúdos dentro do HTMl é utilizando o `XPath`.\nNa imagem a seguir, é possível ver que selecionei a tabela referente à primeira temporada, e ao apertar o código na área Elements com o botão direito do mouse, é possível copiar o `XPath` navegando em \"Copy\" \\> \"Copy XPath\":\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-4_30dcf4ad7c5bed26a395cea9ac0500cc'}\n::: {.cell-output-display}\n![](https://i.ibb.co/3rB68pB/inspetor-de-elementos.png){fig-align='center'}\n:::\n:::\n\n\nO `XPath` copiado é: `//*[@id=\"mw-content-text\"]/div[1]/table[4]`.\nCom isso, podemos acessar os conteúdos da tabela:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_45245068323231f133c98e1cb8e4d8ad'}\n\n```{.r .cell-code}\n# Carregando o pipe do pacote magrittr\nlibrary(magrittr, include.only = \"%>%\")\n\n# Podemos buscar o conteúdo com o xpath, \n# e as tabelas que estão presentescom a função html_table()\ntabela <- \"https://pt.wikipedia.org/wiki/Lista_de_epis%C3%B3dios_de_Naruto_Shippuden\" %>%\n  # ler o html\n  rvest::read_html() %>%\n  # buscar o xpath\n  rvest::html_node(xpath = '//*[@id=\"mw-content-text\"]/div[1]/table[4]') %>% \n  # ler a tabela\n  rvest::html_table()\n```\n:::\n\n\nVamos observar essa tabela referente à primeira temporada: ela contém algumas colunas repetidas, e existe mais de uma linha com informações para o mesmo episódio.\nSerá necessário fazer uma leve **faxina de dados** antes de analisar os dados!\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_6f3b3e719fba8a14ce50d17fba8ea473'}\n\n```{.r .cell-code}\ndplyr::glimpse(tabela)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 90\nColumns: 5\n$ Nº                       <int> 1, 1, NA, 2, 2, NA, 3, 3, NA, 4, 4, NA, 5, 5,…\n$ `Título original`        <chr> \"Volta para Casa\", \"帰郷\", \"\", \"A Akatsuki se…\n$ `Título original`        <chr> \"Volta para Casa\", \"Kikyō\", \"\", \"A Akatsuki s…\n$ `Título(s) em português` <chr> \"Voltando Para Casa\", \"Voltando Para Casa\", \"…\n$ `Data de estreia`        <chr> \"15 de Fevereiro de 2007\", \"15 de Fevereiro d…\n```\n:::\n:::\n\n\nAntes de avançarmos, vamos fazer uma pré-faxina leve: adicionar o número da temporada na base, e transformar o número do episódio em texto (já que a informação se é filler ou não aparece nessa coluna, mas nem todas as temporadas tem fillers - assim padronizamos e evitamos erros posteriormente).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_74f818fb2181ee440ca48941c192fc46'}\n\n```{.r .cell-code}\ntabela %>% \n  # limpar os nomes das variáveis\n  janitor::clean_names() %>% \n  # adicionando o número da temporada \n  dplyr::mutate(numero_temporada = 1,\n                # transforma a variável `no` em texto\n                no = as.character(no)) %>% \n  dplyr::glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 90\nColumns: 6\n$ no                    <chr> \"1\", \"1\", NA, \"2\", \"2\", NA, \"3\", \"3\", NA, \"4\", \"…\n$ titulo_original       <chr> \"Volta para Casa\", \"帰郷\", \"\", \"A Akatsuki se Mo…\n$ titulo_original_2     <chr> \"Volta para Casa\", \"Kikyō\", \"\", \"A Akatsuki se M…\n$ titulo_s_em_portugues <chr> \"Voltando Para Casa\", \"Voltando Para Casa\", \"\", …\n$ data_de_estreia       <chr> \"15 de Fevereiro de 2007\", \"15 de Fevereiro de 2…\n$ numero_temporada      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n```\n:::\n:::\n\n\nJá está um pouco mais claro o que a base contém, né?\n\n### Buscando informações de todas as temporadas!\n\nNa etapa anterior, conseguimos obter a tabela da primeira temporada.\nPodemos criar uma função para buscar as informações de outras temporadas também!\n\nOlhando as tabelas das outras temporadas, é possível observar que o `XPath` segue o mesmo padrão, alterando apenas o número ao final.\nIsso será um argumento na função, chamado `n_tabela`.\nO outro argumento que é interessante adicionar na função é o número da temporada: `numero_temporada`.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_94157905e4568e4e18da5f299abeb341'}\n\n```{.r .cell-code}\nbuscar_tabela <- function(n_tabela, numero_temporada) {\n  # link da página\n  \"https://pt.wikipedia.org/wiki/Lista_de_epis%C3%B3dios_de_Naruto_Shippuden\" %>%\n    # lê o htmo\n    rvest::read_html() %>%\n    # procura pelo xpath\n    rvest::html_node(xpath = glue::glue('//*[@id=\"mw-content-text\"]/div[1]/table[{n_tabela}]')) %>%\n    # lê a tabela\n    rvest::html_table() %>%\n    # limpar os nomes das variáveis\n    janitor::clean_names() %>%\n    # adicionando o numero da temporada como uma variavel\n    # e padronizando o numero do episodio para texto\n    dplyr::mutate(numero_temporada, no = as.character(no))\n}\n```\n:::\n\n\nOs números ao final do `XPath` se iniciam no número 4, e são incrementados de 2 em 2.\nPortanto, **neste caso**, os `XPath` estão organizados dessa forma:\n\n-   Temporada 1: `//*[@id=\"mw-content-text\"]/div[1]/table[4]`\n-   Temporada 2: `//*[@id=\"mw-content-text\"]/div[1]/table[6]`\n-   Temporada 3: `//*[@id=\"mw-content-text\"]/div[1]/table[8]`\n-   ......\n-   Temporada 20: `//*[@id=\"mw-content-text\"]/div[1]/table[42]`\n\nPodemos criar uma sequência com a função `seq()`, para para buscar todas as tabelas de uma vez, sendo que a sequência deve começar no número 4, e incrementar de 2 em 2, até o número 42, formando um vetor de 20 números (referente às 20 temporadas).\n\nPodemos usar a função `purrr::map2_dfr()` para aplicar a função `buscar_tabela()` para buscar as informações das tabelas de todas as temporadas, e unir em uma única base.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_01a593fe7be3fb8baabe8c9287b4fa59'}\n\n```{.r .cell-code}\ntabela_bruta <-\n  purrr::map2_dfr(.x = seq(from = 4, to = 42, by = 2), \n                  # A sequencia começa em 4 e vai até 42, contando de 2 em 2.\n                  # assim teremos um vetor com 20 números, referente às \n                  # 20 temporadas! Isso será usado no primeiro argumento\n                  # da função buscar_tabela, ou seja, \n                  # no argumento  `n_tabela`.\n                  .y = 1:20, # isso será usado no segundo argumento\n                  # da funcao buscar_tabela, ou seja, \n                  # no argumento `numero_temporada`.\n                  .f = buscar_tabela # função que queremos utilizar\n                  )\n```\n:::\n\n\n## Faxina\n\nConseguimos baixar tudo e salvar em uma única base: `tabela_bruta`, porém essa base precisa ser limpa.\nVamos tentar descobrir os problemas?\nA função `dplyr::glimpse()` é útil para dar uma olhada na base:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_d4d31432e40b2c9cc2fe0b240afec29e'}\n\n```{.r .cell-code}\ndplyr::glimpse(tabela_bruta)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,500\nColumns: 6\n$ no                    <chr> \"1\", \"1\", NA, \"2\", \"2\", NA, \"3\", \"3\", NA, \"4\", \"…\n$ titulo_original       <chr> \"Volta para Casa\", \"帰郷\", \"\", \"A Akatsuki se Mo…\n$ titulo_original_2     <chr> \"Volta para Casa\", \"Kikyō\", \"\", \"A Akatsuki se M…\n$ titulo_s_em_portugues <chr> \"Voltando Para Casa\", \"Voltando Para Casa\", \"\", …\n$ data_de_estreia       <chr> \"15 de Fevereiro de 2007\", \"15 de Fevereiro de 2…\n$ numero_temporada      <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n```\n:::\n:::\n\n\nVamos então listar os problemas para arrumar e deixar a base tidy:\n\n1.  Tem variáveis que estão duplicadas, como o título do episódio;\n\n2.  A data de estreia do episódio está como tipo texto;\n\n3.  A informação se o episódio é filler está contido na variável do número do episódio;\n\n4.  Queremos apenas uma linha por episódio;\n\nVamos então fazer uma faxina nessa base, e deixar ela tidy!\nVamos começar tentando resolver os itens 1 à 3:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_01328b5a9156082d1fbd09a2609aed03'}\n\n```{.r .cell-code}\ntabela_faxinando <- tabela_bruta  %>%\n  \n  # separar a coluna `no` em: `numero_episodio` e `tipo_episodio`\n  tidyr::separate(no, into = c(\"numero_episodio\", \"tipo_episodio\"), \"\\\\(\", extra = \"merge\") %>% \n  \n  dplyr::mutate(\n    # transformar a variavel `numero_episodio` em tipo numérico\n    numero_episodio = readr::parse_number(numero_episodio),\n    \n    # remover o parenteses desnecessário na variável tipo_episodio\n    tipo_episodio = stringr::str_replace_all(tipo_episodio, \"\\\\)\", \"\"),\n    \n    # Na variavel `tipo_episodio`, quando está vazio é porque faz\n    # parte da história principal (é chamado de Canônico).\n    # Então vamos usar dplyr::case_when() para arrumar essa variável.\n    tipo_episodio = dplyr::case_when(\n      is.na(tipo_episodio) ~ \"Canon\",\n      tipo_episodio == \"½filler\" ~ \"Semi-filler\",\n      TRUE ~ tipo_episodio\n    ), \n    \n    # transformar a variavel `data_de_estreia` em tipo data\n    data_de_estreia = readr::parse_date(\n      data_de_estreia,\n      format = \"%d de %B de %Y\",\n      locale = readr::locale(\"pt\")\n    )\n  )  %>%\n  # remover colunas repetidas do titulo do episodio\n  dplyr::select(-titulo_original, -titulo_original_2) %>%\n  \n  # renomeia para deixar o nome da variável mais claro\n  dplyr::rename(\"titulo_episodio\" = titulo_s_em_portugues) %>%\n  \n  # move a coluna numero_temporada para o inicio\n  dplyr::relocate(numero_temporada, .before = numero_episodio)\n```\n:::\n\n\nArrumamos algumas coisas já, e a tabela está bem melhor: não tem mais variáveis duplicadas, os nomes das variáveis estão padronizados, as classes das variáveis também estão adequadas:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-12_ad744e1c1f850b94fe19562f3661e01a'}\n\n```{.r .cell-code}\ndplyr::glimpse(tabela_faxinando)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,500\nColumns: 5\n$ numero_temporada <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ numero_episodio  <dbl> 1, 1, NA, 2, 2, NA, 3, 3, NA, 4, 4, NA, 5, 5, NA, 6, …\n$ tipo_episodio    <chr> \"Canon\", \"Canon\", \"Canon\", \"Canon\", \"Canon\", \"Canon\",…\n$ titulo_episodio  <chr> \"Voltando Para Casa\", \"Voltando Para Casa\", \"\", \"Os A…\n$ data_de_estreia  <date> 2007-02-15, 2007-02-15, NA, 2007-02-15, 2007-02-15, …\n```\n:::\n:::\n\n\nAgora vamos arrumar algo muito importante: queremos que cada linha represente um episódio único.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-13_6922a23c14b642abacf04f755be1a003'}\n\n```{.r .cell-code}\nepisodios_naruto_shippuden <- tabela_faxinando %>% \n  # remover os NA`s presentes na coluna  `numero_episodio`\n  tidyr::drop_na(numero_episodio)  %>% \n  # aqui teremos duas linhas por episódio, sendo que elas estão repetidas.\n  # a função dplyr::distinct() permitirá descartar as linhas repetidas\n  dplyr::distinct()\n```\n:::\n\n\nPronto!\nAgora temos na tabela apenas uma linha por episódio.\nPodemos verificar isso com o `dplyr::glimpse()` novamente: a série tem 500 episódios, e a base gerada contém 500 linhas.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-14_bf12d26cbb2cf1b1ae063a04cefdbe28'}\n\n```{.r .cell-code}\ndplyr::glimpse(episodios_naruto_shippuden)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 500\nColumns: 5\n$ numero_temporada <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ numero_episodio  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16…\n$ tipo_episodio    <chr> \"Canon\", \"Canon\", \"Canon\", \"Canon\", \"Canon\", \"Canon\",…\n$ titulo_episodio  <chr> \"Voltando Para Casa\", \"Os Akatsuki Entram em Ação\", \"…\n$ data_de_estreia  <date> 2007-02-15, 2007-02-15, 2007-02-22, 2007-03-01, 2007…\n```\n:::\n:::\n\n\nAlém disso, conseguimos conferir a quantidade de episódios filler:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-15_a2f2c2ba17a1621c5289f5a7c7bb5194'}\n\n```{.r .cell-code}\nepisodios_naruto_shippuden %>% \n  dplyr::count(tipo_episodio, sort = TRUE) %>% \n  knitr::kable(col.names = c(\"Tipo de episódio\", \"Número de episódios\"))\n```\n\n::: {.cell-output-display}\n|Tipo de episódio | Número de episódios|\n|:----------------|-------------------:|\n|Canon            |                 259|\n|Filler           |                 188|\n|Novel            |                  25|\n|Semi-filler      |                  23|\n|Gaiden           |                   4|\n|Omake            |                   1|\n:::\n:::\n\n\n## Visualização\n\nAgora que já temos a base arrumada, podemos fazer uma visualização para descobrir a distribuição de episódios fillers no anime.\nA visualização abaixo está separada por temporada, sendo que a ordem dos episódios no gráfico é: inicia no canto inferior esquerdo, e sobe em direção ao canto superior esquerdo.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-16_497a0e7265cb30aee601a6c78ccd9261'}\n\n```{.r .cell-code}\n# Criando a paleta de cores para usar\n\npaleta <- c(\"#fe7934\",\n            \"#5b8cb9\",\n            \"#083b7c\",\n            \"#e1e020\",\n            \"#ba1820\",\n            \n            \"#403e4b\")\n\n# O pacote que disponibiliza a função ggwaffle é:\n# devtools::install_github(\"hrbrmstr/waffle\")\n\n\n# Criando a visualização:\n grafico <- episodios_naruto_shippuden %>%\n  dplyr::count(numero_temporada, numero_episodio, tipo_episodio) %>%\n   dplyr::mutate(tipo_episodio = forcats::fct_relevel(\n     tipo_episodio,\n     c(\"Canon\", \"Omake\", \"Novel\", \"Gaiden\", \"Semi-filler\", \"Filler\")\n   )) %>% \n  ggplot2::ggplot(ggplot2::aes(fill = tipo_episodio, values = n)) +\n  waffle::geom_waffle(\n    n_rows = 5,\n    color = \"white\",\n    show.legend = TRUE,\n    alpha = 0.9\n  ) +\n  ggplot2::facet_wrap( ~ numero_temporada) +\n  ggplot2::theme_void() +\n  ggplot2::scale_fill_manual(values = paleta) +\n  ggplot2::labs(fill = \"Tipo de episódio\",\n                title = \"Temporadas de Naruto Shippuden \\n\") +\n  ggplot2::theme(\n    text = ggplot2::element_text(family = \"Ninja Naruto\", color = \"white\"),\n    plot.margin = ggplot2::margin(.5, .5, .5, .5, \"cm\"),\n    plot.title =  ggplot2::element_text(\n      hjust = 0.5,\n      size = 20,\n      color = paleta[3]\n    ),\n    legend.position = \"bottom\"\n  )\n\n# Imagem que usaremos de fundo\nimagem <-\n  \"https://uploaddeimagens.com.br/images/003/256/849/full/Monumento_dos_Hokage.jpg?1621801239\"\n\n\n# Colocando uma imagem de fundo\nggimage::ggbackground(gg = grafico,\n                      background = imagem)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-17_45df2ca5d4975aa35cbd168849b6410d'}\n::: {.cell-output-display}\n![](original.png){fig-align='center'}\n:::\n:::\n\n\nEdit: Comentaram que a paleta de cores não facilitou a visualização para pessoas daltônicas, então fiz uma versão com a paleta [viridis](https://ggplot2.tidyverse.org/reference/scale_viridis.html) (obrigada Luiz Paulo Carvalho!):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-18_0675c50c696a8f8a2cad7c45e2697a78'}\n\n```{.r .cell-code}\ngrafico_viridis <- grafico +\n  ggplot2::scale_fill_viridis_d()\n\nggimage::ggbackground(gg = grafico_viridis,\n                      background = imagem)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-19_e096669e83788ed874a0722c263cc920'}\n::: {.cell-output-display}\n![](viridis.png){fig-align='center'}\n:::\n:::\n\n\nAs únicas temporadas livres de *fillers* são a primeira e a segunda!\nDepois de concluir essas temporadas é importante ficar de olho na lista para não acabar assistindo os episódios de enrolação.\n\n## Conclusão\n\nEspero que esse post tenha sido interessante, e seja útil para ~~quem não quer perder tempo com fillers~~ quem deseja obter algum conteúdo do Wikipédia de forma mais fácil!\n\nTchau!\nAté a próxima!\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-20_a8fd5d58b021beae183b5253dfc9f2ab'}\n::: {.cell-output-display}\n![](https://media.giphy.com/media/sr9VDW732xLby/giphy.gif){fig-align='center'}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}