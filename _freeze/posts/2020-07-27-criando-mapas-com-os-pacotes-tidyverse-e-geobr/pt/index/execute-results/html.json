{
  "hash": "d7da97145767cfb74545955bf987bcb3",
  "result": {
    "markdown": "---\ntitle: \"Criando mapas com os pacotes tidyverse e geobr\"\nsubtitle: \"Utilizando dados sobre coleta e tratamento de esgoto no Estado De São Paulo\"\nauthor: \"Beatriz Milz\"\ndate: '2020-07-27'\ncategories: [\"Reproducibility\", \"Maps\"]\nbibliography: packages.bib\nimage: \"featured.png\"\ntoc: true\n---\n\n\n\n\nComo eu estou meses sem postar nada no blog, resolvi postar um código adaptado, referente a um projeto final que realizei para a disciplina [\"FLS6397 - Introdução à Análise de Dados, Programação e Visualização para as Ciências Sociais\"](https://jonnyphillips.github.io/Ciencia_de_Dados/).\nA disciplina ocorreu no primeiro semestre de 2020, na FFLCH/USP (porém devido à pandemia, a maior parte das aulas foi online).\nNa [página da disciplina](https://jonnyphillips.github.io/Ciencia_de_Dados/), está disponível tutoriais com todo o conteúdo da disciplina, de graça e aberto para todes!\n\nAs instruções para a realização do projeto estão disponíveis na [página da disciplina](https://jonnyphillips.github.io/Ciencia_de_Dados/projeto.html).\n\n## Dados utilizados\n\n-   **Dados de Saneamento:** A Companhia Ambiental do Estado de São Paulo (CETESB)[^1] publica todos os anos o \"[Relatório de Qualidade das Águas Interiores do Estado de São Paulo](https://cetesb.sp.gov.br/aguas-interiores/publicacoes-e-relatorios/)\".\n    Desde o relatório referente ao ano de 2016, é publicado o **Apêndice C**, que contém **dados de saneamento por município** do Estado de São Paulo.\n    Os arquivos são disponibilizados em arquivo PDF, [e especificamente para o ano de 2016 é um arquivo PDF que não possibilita copiar as informações](https://cetesb.sp.gov.br/aguas-interiores/wp-content/uploads/sites/12/2018/03/Ap%C3%AAndice-C-Dados-do-saneamento-b%C3%A1sico...-munic%C3%ADpios-paulistas-2016_17-04.pdf) (como uma imagem, por exemplo).\n    O relatório mais recente é referente ao ano de [2018](https://cetesb.sp.gov.br/aguas-interiores/wp-content/uploads/sites/12/2019/10/Ap%C3%AAndice-C_Dados-de-Saneamento-por-Munic%C3%ADpio.pdf).\n\n-   **Dados shapefile dos municípios:** Foi utilizado o pacote `{geobr}` [@R-geobr], que possibilita acessar dados espaciais oficiais do Brasil.\n\n[^1]: https://cetesb.sp.gov.br/\n\nNeste post, irei focar em mostrar como abri os dados, e utilizando principalmente o `tidyverse` [@tidyverse2019] e o pacote `geobr` [@R-geobr], criei mapas com esses dados.\n\n## Pacotes necessários\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(magrittr)\nlibrary(geobr)\n# install.packages(\"pdftables\")\nlibrary(pdftables)\nlibrary(readr)\nlibrary(stringr)\nlibrary(abjutils)\nlibrary(ggspatial)\nlibrary(tibble)\nlibrary(knitr)\nlibrary(sf)\n```\n:::\n\n\n::: {.alert .alert-primary role=\"alert\"}\n**O que é `::` ?**\n\nNos códigos abaixo, muitas vezes me refiro à uma função utilizando o formato `pacote::funcao()`, sendo que o que vem antes dos `::` é o nome do pacote em qual à função pertence, e depois dos `::` é o nome da função que quero usar.\n\nIsso é útil pois:\n\n1.  Caso o pacote não esteja carregado com a função `library(pacote)`, ainda sim o R entenderá qual função você está se referindo, e executará o código.\n\n2.  Caso você se refira à uma função apenas pelo nome (sem considerar o `::`), em uma situação onde você carregou pacotes diferentes que possuem funções com nome igual, a função do pacote carregado por último será utilizada.\n    Isso pode causar a execução de uma função indesejada.\n    Portanto, utilizar o `::` ajuda a garantir a utilização da função desejada.\n:::\n\n## Abrir e arrumar as bases brutas\n\n### Dados de Saneamento\n\nO primeiro passo é fazer o download do arquivo PDF referente ao Apêndice C e converter em CSV.\nA função `download.file()` possibilita fazer download de arquivos diretamente do R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Link do relatório\nurl <-\n  \"https://cetesb.sp.gov.br/aguas-interiores/wp-content/uploads/sites/12/2019/10/Ap%C3%AAndice-C_Dados-de-Saneamento-por-Munic%C3%ADpio.pdf\" \n\n\n#Fazer o download do arquivo PDF\n\ndownload.file(url, # URL do arquivo a ser baixado\n              destfile = \"dados/apendice_c_2018.pdf\", # Informar onde quer que seja salvo, e com qual nome e extensão \n              method = \"curl\" # Método utilizado para o download\n              )\n```\n:::\n\n\nPara fazer a conversão, utilizei o pacote `{pdftables}` [@R-pdftables], que possibilita converter o arquivo PDF para CSV diretamente do R, através da API (e omiti a minha chave da API no código):\n\n::: {.alert .alert-primary role=\"alert\"}\n**O que é API?**\n\nÉ a sigla para \"Application Programming Interfaces\", ou em português, \"Interface de programação de aplicações\".\n\nNeste exemplo, caso não fosse utilizar a API, seria necessário realizar o upload do arquivo PDF no site [PDFTables](https://pdftables.com/), e depois baixar o arquivo convertido.\n\nPara utilizar a API, é necessário fazer um cadastro no site, e na aba [API](https://pdftables.com/pdf-to-excel-api) é disponibilizado a chave da API para utilizá-la.\nPosteriormente, pode-se utilizar a função `pdftables::convert_pdf()` para fazer a conversão diretamente do R.\nIsso é muito útil quando temos uma grande quantidade de arquivos, e também para deixar registrado a etapa realizada.\n\nCaso queira saber mais sobre APIs, leia essa [página do material](http://material.curso-r.com/api/) da [Curso-R](http://curso-r.com/).\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Converter o arquivo PDF em CSV. Utilizei a API que obtive no site, mas para compilar, omiti a API key.\n\npdftables::convert_pdf(\"dados/apendice_c_2018.pdf\",\n                       # Arquivo para converter\n                       output_file = \"dados/apendice_c_2018.csv\",\n                       #  Informar onde quer o arquivo gerado\n                       # seja salvo, e com qual nome e extensão\n                       api_key = \"...\" # Chave da API, gerada através do site.\n                       )\n```\n:::\n\n\nA tabela convertida em `.csv` pode ser acessada [neste link](https://beatrizmilz.github.io/2020-FLS6397/projeto_final/dados/apendice_c_2018.csv).\nO próximo passo é carregar a base, usando a função `readr::read_csv()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napendice_c_2018 <-\n  readr::read_csv(\n    \"dados/apendice_c_2018.csv\", # Qual arquivo CSV quero carregar\n    col_names = c(\n      # define o nome das colunas\n      \"ugrhi\",\n      \"municipio\",\n      \"consessao\",\n      \"pop_urbana\",\n      \"atendimento_coleta_porc\",\n      \"atendimento_tratamento_porc\",\n      \"eficiencia\",\n      \"carga_poluidora_potencial\",\n      \"carga_poluidora_remancescente\",\n      \"ictem\",\n      \"corpo_receptor\"\n    ),\n    locale = readr::locale(encoding = \"ISO-8859-1\"),\n    # encoding dos dados\n    skip = 5 # Quantas linhas para pular no CSV antes de começar a ler os dados.\n  )\n```\n:::\n\n\n::: {.alert .alert-primary role=\"alert\"}\n**Encoding?**\n\nUma das informações importantes que utilizei na função para ler os dados no R, no código acima, é o **Encoding**.\nO Encoding está relacionado à codificação dos caracteres.\nVocê já carregou uma base de dados onde os caracteres apareceram desconfigurados, como na imagem abaixo?\nProvavelmente era um erro de Encoding!\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://beatrizmilz.com/img/encoding-error.JPG){fig-align='center' width=80%}\n:::\n:::\n\n\nAo carregar um arquivo, é util saber em qual encoding ele foi salvo.\n\nO recomendado ao salvar um arquivo é utilizar o encoding **UTF-8**.[^2]\n:::\n\n[^2]: https://support.rstudio.com/hc/en-us/articles/200532197-Character-Encoding\n\n-   A base deve conter 645 linhas, referente ao número de municípios no estado de São Paulo[^3]:\n\n[^3]: https://www.al.sp.gov.br/documentacao/municipios-paulistas/\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnrow(apendice_c_2018) # consulta quantas linhas tem na base\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 701\n```\n:::\n:::\n\n\nA base contém mais linhas do que municípios.\nO código abaixo retira linhas que apenas contém NA, e linhas que não apresentam dados dos municípios:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napendice_c_filtrado <- apendice_c_2018 %>%\n  # Filtrar linhas que não contém nome de municípios\n  dplyr::filter(!municipio %in% c(\"Estado de São Paulo\", \"Município\", NA, \"MUNICÍPIO\")) \n```\n:::\n\n\nAgora a base tem 645 linhas, o que corresponde aos 645 municípios do estado de SP.\nÉ importante também verificar o tipo de dados nas colunas:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntibble::glimpse(apendice_c_filtrado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 645\nColumns: 11\n$ ugrhi                         <chr> \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"2\", \"2\", …\n$ municipio                     <chr> \"Campos do Jordão\", \"Santo Antônio do Pi…\n$ consessao                     <chr> \"SABESP\", \"SABESP\", \"SABESP\", \"SAAE\", \"S…\n$ pop_urbana                    <chr> \"51440\", \"4033\", \"5224\", \"35604\", \"1863\"…\n$ atendimento_coleta_porc       <chr> \"52\", \"47\", \"92\", \"70\", \"91\", \"100\", \"89…\n$ atendimento_tratamento_porc   <chr> \"100\", \"100\", \"75\", \"28\", \"100\", \"0\", \"1…\n$ eficiencia                    <chr> \"97\", \"80\", \"76\", \"70\", \"82\", NA, \"62\", …\n$ carga_poluidora_potencial     <chr> \"2.778\", \"218\", \"282\", \"1.923\", \"101\", \"…\n$ carga_poluidora_remancescente <chr> \"1.377\", \"136\", \"133\", \"1.659\", \"26\", \"1…\n$ ictem                         <chr> \"6,06\", \"4,65\", \"6,14\", \"2,56\", \"8,22\", …\n$ corpo_receptor                <chr> \"Rio Capivari, Rio Sapucaí-Guaçu e aflue…\n```\n:::\n:::\n\n\nAlgumas colunas são de dados numéricos mas que foram carregadas como texto (`<chr>`), portanto devem ser convertidas para o tipo correto (possível com a função `dplyr::mutate()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napendice_c <- apendice_c_filtrado %>%\n  dplyr::mutate(\n    pop_urbana = as.double(pop_urbana) , \n    atendimento_coleta_porc = as.double(atendimento_coleta_porc),\n    atendimento_tratamento_porc = as.double(atendimento_tratamento_porc),\n    eficiencia = as.double(eficiencia),\n    \n    # As conversões abaixo tem uma etapa a mais, devido à padronização diferente utilizada na base, \n    #com o ponto e a vírgula para representar as casas decimais:\n    carga_poluidora_potencial =  stringr::str_replace_all(carga_poluidora_potencial, \"\\\\.\", \"\") %>%\n      as.double(),\n    \n    carga_poluidora_remancescente =  stringr::str_replace_all(carga_poluidora_remancescente, \"\\\\.\", \"\") %>%\n      as.double(),\n    ictem =  stringr::str_replace_all(ictem, \",\", \"\\\\.\") %>% as.double()\n    \n  )\n```\n:::\n\n\nAgora podemos observar novamente o tipo de dados nas colunas, e verificar se todos os dados estão no formato ideal para a análise:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntibble::glimpse(apendice_c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 645\nColumns: 11\n$ ugrhi                         <chr> \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"2\", \"2\", …\n$ municipio                     <chr> \"Campos do Jordão\", \"Santo Antônio do Pi…\n$ consessao                     <chr> \"SABESP\", \"SABESP\", \"SABESP\", \"SAAE\", \"S…\n$ pop_urbana                    <dbl> 51440, 4033, 5224, 35604, 1863, 2598, 86…\n$ atendimento_coleta_porc       <dbl> 52, 47, 92, 70, 91, 100, 89, 100, 100, 8…\n$ atendimento_tratamento_porc   <dbl> 100, 100, 75, 28, 100, 0, 100, 99, 100, …\n$ eficiencia                    <dbl> 97, 80, 76, 70, 82, NA, 62, 75, 86, 89, …\n$ carga_poluidora_potencial     <dbl> 2778, 218, 282, 1923, 101, 140, 470, 432…\n$ carga_poluidora_remancescente <dbl> 1377, 136, 133, 1659, 26, 140, 210, 1125…\n$ ictem                         <dbl> 6.06, 4.65, 6.14, 2.56, 8.22, 1.50, 6.92…\n$ corpo_receptor                <chr> \"Rio Capivari, Rio Sapucaí-Guaçu e aflue…\n```\n:::\n:::\n\n\nAgora a base está pronta para uso!\n\n### Dados shapefile dos município\n\nOs dados foram obtidos com o pacote `geobr`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Lê a base de dados espaciais (do tipo Shapefile) dos municípios do Estado de São Paulo,\n# no ano de 2018, segundo o IBGE.\n# Os dados salvos são da classe Simple Feature\n\nmunicipios_sp <- geobr::read_municipality(\"SP\", 2018)\n```\n:::\n\n\n::: {.alert .alert-primary role=\"alert\"}\nO pacote `geobr` [@R-geobr] é um pacote que disponibiliza funções para realizar o download de diversas bases de dados espaciais oficiais do Brasil.\nVocê pode saber mais no [repositório do pacote no GitHub](https://github.com/ipeaGIT/geobr).\n\nO pacote `sf` (Simple Features for R) [@R-sf; @sf2018] possibilita trabalhar com essas bases de dados espaciais.\nGosto muito da seguinte ilustação da [Allison Horst](https://github.com/allisonhorst/stats-illustrations) sobre esse pacote:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork-PT/sf_pt.png){fig-align='center' width=80%}\n:::\n:::\n\n:::\n\n### Lista de UGRHIS\n\nNo projeto, defini como área de estudo os municípios das seguintes Unidades de Gerenciamento de Recursos Hídricos (**UGRHI**): Paraíba do Sul, Litoral Norte, Piracicaba/Capivari/Jundiaí, Alto Tietê, Baixada Santista e Tietê/Sorocaba.\nEssas UGRHIs foram escolhidas por estarem totalmente ou marjoritariamente no território da Macrometrópole Paulista (**MMP**) (considerando a delimitação do DAEE[^4]).\n\n[^4]: Plano Diretor de Aproveitamento dos Recursos Hídricos para a Macrometrópole Paulista - http://www.daee.sp.gov.br/\n\nCriei manualmente uma tibble com o número e nome das UGRHIs que farão parte da análise:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nugrhis <- tibble::tibble(\n  ugrhi = c(\"2\",\n            \"3\",\n            \"5\",\n            \"6\",\n            \"7\",\n            \"10\"),\n  nome_ugrhi = c(\n    \" Paraíba do Sul\",\n    \" Litoral Norte\",\n    \" Piracicaba/Capivari/Jundiaí\",\n    \" Alto Tietê\",\n    \" Baixada Santista\",\n    \" Tietê/Sorocaba\"\n  )\n)\n```\n:::\n\n\n## Unir as bases !\n\nA base da CETESB não possui o código de município do IBGE (o ideal para fazer o Join).\nNeste caso, podemos usar o nome do município, porém é preciso padronizar os nomes em relação à maiúsculas/minúsculas, acentos, presença de traços, entre outros.\nA maior diferença encontrada foi na grafia do nome do município \"São Luiz do Paraitinga\": segundo o site da Assembléia Legislativa do Estado de São Paulo, e o site do município, Luiz é escrito com Z, porém a base da CETESB utiliza a forma incorreta: \"São Luís do Paraitinga\".\nEssas inconsistências foram corrigidas com código abaixo, usando principalmente funções dos pacotes `stringr`, `dplyr` e `abjutils`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmunicipios_sp_limpo <-\n  municipios_sp %>% dplyr::mutate(\n    nome_muni = stringr::str_to_lower(name_muni),\n    nome_muni = stringr::str_replace_all(nome_muni, \"-\", \" \"),\n    nome_muni = abjutils::rm_accent(nome_muni)\n  )\n\napendice_c_limpo <- apendice_c %>% dplyr::mutate(\n  nome_muni =  dplyr::case_when(\n    municipio == \"São Luís do Paraitinga\" ~\n      \"São Luiz do Paraitinga\",\n    TRUE ~ municipio\n  ),\n  nome_muni = stringr::str_to_lower(nome_muni),\n  nome_muni = stringr::str_replace_all(nome_muni, \"-\", \" \"),\n  nome_muni = abjutils::rm_accent(nome_muni))\n```\n:::\n\n\n-   Após arrumar a base, podemos unir com as funções do tipo `join_*`, do pacote `dplyr` (Sim, é possível usar as funções do tipo `join_*` com objetos de classe Simple Feature, porém use-os como o primeiro argumento ao usar a função):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napendice_c_geo <-\n  dplyr::full_join(municipios_sp_limpo, apendice_c_limpo) %>%\n  dplyr::left_join(ugrhis)\n\napendice_c_geo %>% nrow() # Confirmando se a nova base tem o número de municípios do estado.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 645\n```\n:::\n:::\n\n\nAo unir as bases, temos colunas duplicadas ou desnecessárias, então é interessante removê-las.\nApós este procedimento, a base será filtrada para que apenas municípios que fazem parte das UGRHIs analisadas estejam na tibble gerada.\n\nAlém disso, o valor de porcentagem de atendimento de tratamento de esgoto é um valor de porcentagem em relação ao volume de esgoto **coletado**.\nPor exemplo, o município de Bertioga, segundo os dados da CETESB para 2018, apresenta uma porcentagem de coleta de apenas 34 % do esgoto gerado, e uma porcentagem de 100 % do esgoto tratado.\nIsso significa que 100 % do esgoto coletado é tratado, e não mostra a porcentagem de todo esgoto gerado que foi tratado.\nPara isso, criei também uma coluna (chamada `porc_real_trat`) onde é feito esse cálculo (utilizando a função mutate).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsaneamento <- apendice_c_geo %>%\n  dplyr::select(-nome_muni,-municipio,-code_state) %>% # Remove colunas duplicadas\n  dplyr::filter(ugrhi %in% ugrhis$ugrhi) %>% # Filtra a coluna UGRHI. Apenas as UGRHIS que estão na tibble\n                                            # criada, permanecerão.\n  dplyr::mutate(porc_real_trat = atendimento_tratamento_porc * atendimento_coleta_porc / 100) # Cria uma nova\n# coluna, com o cálculo do número real de porcentagem de tratamento de esgoto.\n```\n:::\n\n\nA base final que usaremos na análise contém dados de 171 municípios, que fazem parte de 6 UGRHIs diferentes.\nA soma da população urbana destes municípios é de 32.79 milhões de habitantes, o que corresponde à 75.1 % da população urbana do Estado de São Paulo (segundo os dados da base completa utilizada nessa análise).\n\n## Visualizando os dados\n\nPara evitar duplicação de código, o código abaixo é referente ao estilo do mapa, que aplicarei em todos os mapas seguintes.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntema_mapa <-\n  theme_bw() + # Escolhe o tema. Eu gosto do theme_bw() por ser bem simples/limpo\n  \n  # Os códigos abaixo são referentes à estética do tema,\n  # como o tamanho da fonte, direção do texto,\n  # linhas ao fundo, etc.\n  \n  theme(\n    axis.text.y = element_text(\n      angle = 90,\n      hjust = 0.5,\n      size = 8\n    ),\n    axis.text.x = element_text(size = 8),\n    axis.title.y = element_text(size = rel(0.8)),\n    axis.title.x = element_text(size = rel(0.8)),\n    panel.grid.major = element_line(\n      color = gray(0.9),\n      linetype = \"dashed\",\n      size = 0.1\n    ),\n    panel.background = element_rect(fill = \"white\") +\n      annotation_scale(location = \"br\", width_hint = 0.30)\n  )\n```\n:::\n\n\nCom a função `geom_sf()`, é possível criar mapas utilizando o pacote `ggplot2` e objetos de classe Simple Feature (sf).\nAssim podemos usar as nossas habilidades de criar gráficos lindos no `ggplot2`, e criar mapas também usando as funções que já conhecemos.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(saneamento) # Função class() apresenta a classe do objeto. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\nO mapa abaixo apresenta os municípios que fazem parte da análise, segundo a UGRHI, e a localização destes municípios no Estado de São Paulo.\nPodemos usar mais de uma camada `geom_sf()` no mesmo mapa, da mesma forma que fazemos com o `ggplot2`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsaneamento %>% # Base de dados usada\n  ggplot() + # Inicia o gráfico ggplot\n  geom_sf(data = apendice_c_geo,\n          # Camada do mapa da base completa (Estado SP)\n          alpha = .9,\n          color = NA) +\n  geom_sf(aes(fill = nome_ugrhi)) + # Camada do mapa da base saneamento\n  # Adiciona Título e Legendas\n  labs(fill = \"UGRHI\",\n       title = \"Municípios que fazem parte da análise, segundo a UGRHI\") +\n  # Adiciona o Norte Geográfico\n  annotation_north_arrow(\n    location = \"br\",\n    which_north = \"true\",\n    height = unit(1, \"cm\"),\n    width = unit(1, \"cm\"),\n    pad_x = unit(0.1, \"in\"),\n    pad_y = unit(0.1, \"in\"),\n    style = north_arrow_fancy_orienteering\n  ) +\n  ggspatial::annotation_scale() +\n  # Adiciona o tema criado anteriormente\n  tema_mapa \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mapa-area-estudo-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nO mapa abaixo apresenta a porcentagem de atendimento de coleta de esgoto, por município:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsaneamento %>%\n  ggplot() +\n  geom_sf(aes(fill = atendimento_coleta_porc)) +\n  scale_fill_viridis_c(direction = -1, limits = c(0, 100)) + # Escala de cores\n  labs(fill = \"Porcentagem de \\natendimento de \\ncoleta de esgoto\",\n       title = \"Porcentagem de atendimento de coleta de esgoto, por município\",\n       subtitle = \"Dados da CETESB, para o ano de 2018.\") +\n  annotation_north_arrow(\n    location = \"br\",\n    which_north = \"true\",\n    height = unit(1, \"cm\"),\n    width = unit(1, \"cm\"),\n    pad_x = unit(0.1, \"in\"),\n    pad_y = unit(0.1, \"in\"),\n    style = north_arrow_fancy_orienteering\n  ) +\n  ggspatial::annotation_scale() +\n  tema_mapa \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mapa-coleta-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nO mapa abaixo apresenta a porcentagem de atendimento de tratamento de esgoto, considerando o total de esgoto coletado, por município:\n\n\n::: {.cell layout-align=\"center\" preview='true'}\n\n```{.r .cell-code}\nsaneamento %>%\n  ggplot() +\n  geom_sf(aes(fill = porc_real_trat)) +\n  scale_fill_viridis_c(direction = -1, limits = c(0, 100)) +\n  labs(fill = \"% de \\natendimento de \\ntratamento de esgoto \",\n       title = \"Porcentagem de atendimento de tratamento de esgoto, por município\",\n       subtitle = \"Calculado a partir de dados da CETESB, para o ano de 2018.\") +\n  annotation_north_arrow(\n    location = \"br\",\n    which_north = \"true\",\n    height = unit(1, \"cm\"),\n    width = unit(1, \"cm\"),\n    pad_x = unit(0.1, \"in\"),\n    pad_y = unit(0.1, \"in\"),\n    style = north_arrow_fancy_orienteering\n  ) +\n  ggspatial::annotation_scale() +\n  tema_mapa \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mapa-tratamento-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Conclusão do post\n\nNeste post, mostrei um caminho reprodutível e realizado utilizando o R:\n\n-   Com o pacote `pdftables`, é possível converter tabelas que estão em arquivos PDF para arquivos CSV.\n\n-   Com o pacote `geobr`, é possível obter os arquivos shapefile para os mapas.\n\n-   Com as funções dos pacotes que fazem parte do `tidyverse`, diversas etapas da análise de dados são possíveis: ler os dados no R, limpeza de dados, manipulação dos dados, cruzamento de bases de dados, visualização, e outros.\n\n## Recomendações para a base da CETESB\n\n-   Adicionar uma explicação sobre cada coluna da base disponibilizada.\n\n-   Seria melhor disponibilizar também o arquivo `.CSV`.\n    Não disponibilizar PDFs digitalizados (Ex: relatório do ano de 2016).\n\n-   Seria útil adicionar, para os próximos relatórios, a coluna de código IBGE do município.\n    Isso facilitaria o cruzamento com outras bases de dados.\n\n-   Verificar a grafia do nome dos municípios (está inconsistente com a lista de municípios da Assembléia Legislativa do Estado de São Paulo[^5]): São Luiz do Paraitinga, Biritiba Mirim, Itaoca.\n\n[^5]: https://www.al.sp.gov.br/documentacao/municipios-paulistas/\n\n## Informações sobre a sessão do R e RStudio\n\n-   As informações abaixo são interessantes para registrar a versão do R utilizada, versões de pacotes, entre outros.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.2 (2021-11-01)\n os       macOS Big Sur 11.6.6\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Sao_Paulo\n date     2022-06-12\n pandoc   2.17.1.1 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n abjutils    * 0.3.2      2022-02-01 [1] CRAN (R 4.1.1)\n assertthat    0.2.1      2019-03-21 [1] CRAN (R 4.1.0)\n bit           4.0.4      2020-08-04 [1] CRAN (R 4.1.0)\n bit64         4.0.5      2020-08-30 [1] CRAN (R 4.1.0)\n class         7.3-20     2022-01-13 [1] CRAN (R 4.1.1)\n classInt      0.4-3      2020-04-07 [1] CRAN (R 4.1.0)\n cli           3.3.0      2022-04-25 [1] CRAN (R 4.1.2)\n colorspace    2.0-3      2022-02-21 [1] CRAN (R 4.1.1)\n crayon        1.5.1      2022-03-26 [1] CRAN (R 4.1.1)\n crul          1.2.0      2021-11-22 [1] CRAN (R 4.1.1)\n curl          4.3.2      2021-06-23 [1] CRAN (R 4.1.0)\n data.table    1.14.2     2021-09-27 [1] CRAN (R 4.1.1)\n DBI           1.1.2      2021-12-20 [1] CRAN (R 4.1.1)\n digest        0.6.29     2021-12-01 [1] CRAN (R 4.1.1)\n dplyr       * 1.0.9      2022-04-28 [1] CRAN (R 4.1.1)\n e1071         1.7-9      2021-09-16 [1] CRAN (R 4.1.1)\n ellipsis      0.3.2      2021-04-29 [1] CRAN (R 4.1.0)\n evaluate      0.15       2022-02-18 [1] CRAN (R 4.1.1)\n fansi         1.0.3      2022-03-24 [1] CRAN (R 4.1.1)\n farver        2.1.0      2021-02-28 [1] CRAN (R 4.1.0)\n fastmap       1.1.0      2021-01-25 [1] CRAN (R 4.1.0)\n generics      0.1.2      2022-01-31 [1] CRAN (R 4.1.1)\n geobr       * 1.6.1      2021-04-16 [1] CRAN (R 4.1.0)\n ggplot2     * 3.3.6      2022-05-03 [1] CRAN (R 4.1.1)\n ggspatial   * 1.1.5      2021-01-04 [1] CRAN (R 4.1.0)\n glue          1.6.2      2022-02-24 [1] CRAN (R 4.1.1)\n gtable        0.3.0      2019-03-25 [1] CRAN (R 4.1.0)\n hms           1.1.1      2021-09-26 [1] CRAN (R 4.1.1)\n htmltools     0.5.2.9000 2022-03-14 [1] Github (rstudio/htmltools@9490b62)\n htmlwidgets   1.5.4      2021-09-08 [1] CRAN (R 4.1.1)\n httpcode      0.3.0      2020-04-10 [1] CRAN (R 4.1.0)\n httr          1.4.3      2022-05-04 [1] CRAN (R 4.1.1)\n jsonlite      1.8.0      2022-02-22 [1] CRAN (R 4.1.1)\n KernSmooth    2.23-20    2021-05-03 [1] CRAN (R 4.1.2)\n knitr       * 1.39       2022-04-26 [1] CRAN (R 4.1.1)\n labeling      0.4.2      2020-10-20 [1] CRAN (R 4.1.0)\n lifecycle     1.0.1      2021-09-24 [1] CRAN (R 4.1.1)\n magrittr    * 2.0.3      2022-03-30 [1] CRAN (R 4.1.1)\n munsell       0.5.0      2018-06-12 [1] CRAN (R 4.1.0)\n pdftables   * 0.1        2016-02-15 [1] CRAN (R 4.1.0)\n pillar        1.7.0      2022-02-01 [1] CRAN (R 4.1.1)\n pkgconfig     2.0.3      2019-09-22 [1] CRAN (R 4.1.0)\n proxy         0.4-26     2021-06-07 [1] CRAN (R 4.1.0)\n purrr         0.3.4      2020-04-17 [1] CRAN (R 4.1.0)\n R6            2.5.1      2021-08-19 [1] CRAN (R 4.1.1)\n Rcpp          1.0.8.3    2022-03-17 [1] CRAN (R 4.1.1)\n readr       * 2.1.2      2022-01-30 [1] CRAN (R 4.1.1)\n rlang         1.0.2      2022-03-04 [1] CRAN (R 4.1.1)\n rmarkdown     2.14.2     2022-05-28 [1] Github (rstudio/rmarkdown@f2bfeec)\n rstudioapi    0.13       2020-11-12 [1] CRAN (R 4.1.0)\n s2            1.0.7      2021-09-28 [1] CRAN (R 4.1.1)\n scales        1.2.0      2022-04-13 [1] CRAN (R 4.1.1)\n sessioninfo   1.2.2      2021-12-06 [1] CRAN (R 4.1.1)\n sf          * 1.0-7      2022-03-07 [1] CRAN (R 4.1.1)\n stringi       1.7.6      2021-11-29 [1] CRAN (R 4.1.1)\n stringr     * 1.4.0      2019-02-10 [1] CRAN (R 4.1.1)\n tibble      * 3.1.7      2022-05-03 [1] CRAN (R 4.1.1)\n tidyselect    1.1.2      2022-02-21 [1] CRAN (R 4.1.1)\n triebeard     0.3.0      2016-08-04 [1] CRAN (R 4.1.0)\n tzdb          0.3.0      2022-03-28 [1] CRAN (R 4.1.1)\n units         0.8-0      2022-02-05 [1] CRAN (R 4.1.1)\n urltools      1.7.3      2019-04-14 [1] CRAN (R 4.1.0)\n utf8          1.2.2      2021-07-24 [1] CRAN (R 4.1.0)\n vctrs         0.4.1      2022-04-13 [1] CRAN (R 4.1.1)\n viridisLite   0.4.0      2021-04-13 [1] CRAN (R 4.1.0)\n vroom         1.5.7      2021-11-30 [1] CRAN (R 4.1.1)\n withr         2.5.0      2022-03-03 [1] CRAN (R 4.1.1)\n wk            0.6.0      2022-01-03 [1] CRAN (R 4.1.1)\n xfun          0.31       2022-05-10 [1] CRAN (R 4.1.2)\n yaml          2.3.5      2022-02-21 [1] CRAN (R 4.1.1)\n\n [1] /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\nO projeto foi realizado com R [@R-base], e os pacotes: `{abjutils}` [@R-abjutils], `{dplyr}` [@R-dplyr], `{geobr}` [@R-geobr], `{ggplot2}` [@R-ggplot2; @ggplot22016], `{ggspatial}` [@R-ggspatial], `{knitr}` [@R-knitr; @knitr2015], `{magrittr}` [@R-magrittr], `{pdftables}` [@R-pdftables], `{readr}` [@R-readr], `{rmarkdown}` [@R-rmarkdown; @rmarkdown2018], `{sf}` [@R-sf; @sf2018], `{stringr}` [@R-stringr], `{tibble}` [@R-tibble].\n\n## Muito obrigada!\n\n-   Ao Professor [Jonathan Phillips](https://jonnyphillips.github.io/Website/), pelo oferecimento da disciplina [\"FLS6397 - Introdução à Análise de Dados, Programação e Visualização para as Ciências Sociais\"](https://jonnyphillips.github.io/Ciencia_de_Dados/), por sua disponibilidade para tirar as dúvidas de todes, disponibilização de todo material da aula na internet de forma aberta e gratuita, e pelo esforço para que a disciplina fosse proveitosa mesmo considerando o contexto de pandemia.\n\n-   A [Vanessa Escolano Maso](https://bv.fapesp.br/pt/pesquisador/705683/vanessa-escolano-maso/), amiga, parceira na R-Ladies São Paulo e também na disciplina, pela companhia durante a disciplina e também por revisar e sugerir melhoras neste post.\n\n-   Ao [Maurício Vancine](https://twitter.com/mauriciovancine) pela sua sugestão via [twitter](https://twitter.com/mauriciovancine/status/1287852208449638402?s=20) de utilizar a função `ggspatial::annotation_scale()` para adicionar uma barra de escala nos gráficos.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}